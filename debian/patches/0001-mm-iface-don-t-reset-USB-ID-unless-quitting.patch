From 6ab5156dfacbf5d98f0c3c2e991cbe1cf85ca9e6 Mon Sep 17 00:00:00 2001
From: Arnaud Ferraris <arnaud.ferraris@collabora.com>
Date: Fri, 11 Dec 2020 14:31:20 +0100
Subject: [PATCH] mm-iface: don't reset USB ID unless quitting

As ModemManager releases the modem while going to sleep, we clear the
USB ID too, which causes a segfault when trying to recover the modem.
---
 src/mm-iface.c | 15 +++++----------
 1 file changed, 5 insertions(+), 10 deletions(-)

diff --git a/src/mm-iface.c b/src/mm-iface.c
index f1021de..f6ec6eb 100644
--- a/src/mm-iface.c
+++ b/src/mm-iface.c
@@ -84,13 +84,8 @@ static void interface_removed_cb(struct EG25Manager *manager,
 
     g_message("ModemManager interface `%s' removed on object `%s'", info->name, path);
 
-    if (g_strcmp0(info->name, MM_DBUS_INTERFACE_MODEM) == 0) {
+    if (g_strcmp0(info->name, MM_DBUS_INTERFACE_MODEM) == 0)
         manager->mm_modem = NULL;
-        if (manager->modem_usb_id) {
-            g_free(manager->modem_usb_id);
-            manager->modem_usb_id = NULL;
-        }
-    }
 }
 
 
@@ -133,10 +128,6 @@ static void object_removed_cb(struct EG25Manager *manager, GDBusObject *object)
     g_message("ModemManager object `%s' removed", path);
 
     manager->mm_modem = NULL;
-    if (manager->modem_usb_id) {
-        g_free(manager->modem_usb_id);
-        manager->modem_usb_id = NULL;
-    }
 }
 
 
@@ -196,6 +187,10 @@ void mm_iface_destroy(struct EG25Manager *manager)
         g_clear_object(&manager->mm_manager);
         manager->mm_manager = NULL;
     }
+    if (manager->modem_usb_id) {
+        g_free(manager->modem_usb_id);
+        manager->modem_usb_id = NULL;
+    }
     if (manager->mm_watch != 0) {
         g_bus_unwatch_name(manager->mm_watch);
         manager->mm_watch = 0;
-- 
2.29.2

